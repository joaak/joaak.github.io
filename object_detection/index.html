
<!DOCTYPE html>
<html>
  <head>
  </head>
  <body onload="init();">
    <h1> Take a snapshot of the current video stream </h1>
   Click on the Start WebCam button.
     <p>
       <button onclick="startWebcam();"> Start WebCam </button>
       <button onclick="stopWebcam();"> Stop WebCam </button> 
       <button onclick="snapshot();"> Take Snapshot </button> 
    </p>
    <video onclick="snapshot(this);" width=400 height=400 id="video" controls autoplay></video>
  <p>

        Screenshots : <p>
      <canvas  id="myCanvas" width="224" height="224"></canvas>  
  <hr>
    <div class="create-model">
      <button id="load-model" style="display:none"> Load model </button>
    </div>
  </hr>
  
  </body>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
  
  <script>
  
      //--------------------
      // GET USER MEDIA CODE
      //--------------------
      
      navigator.getUserMedia = (navigator.getUserMedia ||
                                navigator.webkitGetUserMedia ||
                                navigator.mozGetUserMedia ||
                                navigator.msGetUserMedia);

      var video;
      var webcamStream;

      function startWebcam() {
        if (navigator.getUserMedia) {
           navigator.getUserMedia (

              // constraints
              {
                 video: true,
                 audio: false
              },

              // successCallback
              function(localMediaStream) {
                 video = document.querySelector('video');
                 video.src = window.URL.createObjectURL(localMediaStream);
                 webcamStream = localMediaStream;
              },

              // errorCallback
              function(err) {
                 console.log("The following error occured: " + err);
              }
           );
        } else {
           console.log("getUserMedia not supported");
        }  
      }

      function stopWebcam() {
          webcamStream.stop();
      }
      
      //---------------------
      // TAKE A SNAPSHOT CODE
      //---------------------
      
      var canvas, ctx;

      function init() {
        // Get the canvas and obtain a context for
        // drawing in it
        canvas = document.getElementById("myCanvas");
        ctx = canvas.getContext('2d');
        
      }

      function snapshot() {
         // Draws current image from the video element into the canvas
        ctx.drawImage(video, 0,0, canvas.width, canvas.height);
        console.log(video);
      }
      
      //------------
      // MODEL STUFF
      //------------
      
      const HOSTED_URLS = {
          model:
              'model_js/model.json',
          metadata:
              'model_js/metadata.json'
       };
       
       function status(statusText) {
         console.log(statusText);
         document.getElementById('status').textContent = statusText;
       }
       
       function setimgField(img, predict) {
         const imgField = document.getElementById("myCanvas");
         imgField.value = img;
         doPredict(predict);
      }
      
      function setPredictFunction(predict) {
        const imgField = document.getElementById("myCanvas");
        imgField.addEventListener(() => doPredict(predict));
      }

      function doPredict(predict) {
        const imgField = document.getElementById("myCanvas");
        const result = predict(imgField.value);
      }  
       
       async function urlExists(url) {
        status('Testing url ' + url);
        try {
          const response = await fetch(url, {method: 'HEAD'});
          return response.ok;
        } catch (err) {
          return false;
        }
      }

       async function loadHostedPretrainedModel(url) {
         status('Loading pretrained model from ' + url);
         try {
           const model = await tf.loadModel(url);
           status('Done loading pretrained model.');
           disableLoadModelButtons();
           return model;
         } catch (err) {
           console.error(err);
           status('Loading pretrained model failed.');
         }
       }

       async function loadHostedMetadata(url) {
         status('Loading metadata from ' + url);
         try {
           const metadataJson = await fetch(url);
           const metadata = await metadataJson.json();
           status('Done loading metadata.');
           return metadata;
         } catch (err) {
           console.error(err);
           status('Loading metadata failed.');
         }
       }
       
       class Classifier {

          async init(urls) {
            this.urls = urls;
            this.model = await loadHostedPretrainedModel(urls.model);
            await this.loadMetadata();
            return this;
          }

          async loadMetadata() {
            const metadata =
                await loadHostedMetadata(this.urls.metadata);
            showMetadata(metadata);
            this.category_index = metadata['category_index'];
          }

          predict(image) {
            // Convert to lower case and remove all punctuations.
            const inputText =
                text.trim().toLowerCase().replace(/(\.|\,|\!)/g, '').split(' ');
            // Look up word indices.
            const inputBuffer = tf.buffer([1, this.maxLen], 'float32');
            for (let i = 0; i < inputText.length; ++i) {
              const word = inputText[i];
              inputBuffer.set(this.wordIndex[word], 0, i);
              //console.log(word, this.wordIndex[word], inputBuffer);
            }
            
            const input = inputBuffer.toTensor();
            //console.log(input);

            status('Running inference:');
            const beginMs = performance.now();
            const predictOut = this.model.predict(input);
            //console.log(predictOut.dataSync());
            const score = predictOut.dataSync();//[0];
            predictOut.dispose();
            const endMs = performance.now();

            return {score: score, elapsed: (endMs - beginMs)};
          }
        };

        async function setup() {
          if (await urlExists(HOSTED_URLS.model)) {
            status('Model available: ' + HOSTED_URLS.model);
            const button = document.getElementById('load-model');
            button.addEventListener('click', async () => {
              const predictor = await new Classifier().init(HOSTED_URLS);
            });
            button.style.display = 'inline-block';
          }

          status('Standing by.');
        }





  </script>
</html>
